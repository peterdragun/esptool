name: 'Python Executable Build'
description: 'Build Python applications into standalone executables for multiple architectures'
inputs:
  python-files:
    description: 'Space-separated list of Python files to build'
    required: true
  output-dir:
    description: 'Output directory for built executables'
    required: true
  include-data-dirs:
    description: 'JSON object mapping script names to data directories to include. Supports wildcards (*) and exact matches. Format: {"script.py": [{"src": "./data", "dest": "./data"}], "*": [{"src": "./common", "dest": "./common"}]} or legacy list format for backward compatibility.'
    required: false
    default: '[]'
  icon-file:
    description: 'Path to icon file (Windows only)'
    required: false
    default: ''
  target-platform:
    description: 'Target platform: windows-amd64, linux-amd64, macos-amd64, macos-arm64, linux-armv7, linux-aarch64'
    required: true
  python-version:
    description: 'Python version to use. Make sure that the version is available on all runners.'
    required: false
    default: '3.11'
  pyinstaller-version:
    description: 'PyInstaller version to install'
    required: false
    default: 'latest'
  additional-args:
    description: 'Additional PyInstaller arguments'
    required: false
    default: ''
  pip-extra-index-url:
    description: 'Extra pip index URL'
    required: false
    default: 'https://dl.espressif.com/pypi'
  install-deps-command:
    description: 'Command to install project dependencies. Command will be executed like `python -m {install-deps-command}`'
    required: false
    default: 'pip install --user --prefer-binary -e .'
  additional-arm-packages:
    description: 'ARM ONLY: Additional system packages to install (space-separated). e.g. for cryptography: openssl libffi-dev libffi7 libssl-dev'
    required: false
    default: ''
  test-command-args:
    description: 'Command arguments to test binaries (e.g. "-h")'
    required: false
    default: '-h'

outputs:
  executable-extension:
    description: 'File extension of built executables'
    value: ${{ steps.setup-platform.outputs.exe-extension }}
  build-success:
    description: 'Whether the build was successful'
    value: ${{ steps.build.outputs.success }}

runs:
  using: 'composite'
  steps:
    - name: Setup platform variables
      id: setup-platform
      shell: bash
      run: |
        case "${{ inputs.target-platform }}" in
          windows-amd64)
            echo "exe-extension=.exe" >> $GITHUB_OUTPUT
            echo "is-windows=true" >> $GITHUB_OUTPUT
            echo "is-linux-arm=false" >> $GITHUB_OUTPUT
            echo "data-separator=;" >> $GITHUB_OUTPUT
            ;;
          linux-amd64)
            echo "exe-extension=" >> $GITHUB_OUTPUT
            echo "is-windows=false" >> $GITHUB_OUTPUT
            echo "is-linux-arm=false" >> $GITHUB_OUTPUT
            echo "data-separator=:" >> $GITHUB_OUTPUT
            ;;
          macos-amd64|macos-arm64)
            echo "exe-extension=" >> $GITHUB_OUTPUT
            echo "is-windows=false" >> $GITHUB_OUTPUT
            echo "is-linux-arm=false" >> $GITHUB_OUTPUT
            echo "data-separator=:" >> $GITHUB_OUTPUT
            ;;
          linux-armv7)
            echo "exe-extension=" >> $GITHUB_OUTPUT
            echo "is-windows=false" >> $GITHUB_OUTPUT
            echo "is-linux-arm=true" >> $GITHUB_OUTPUT
            echo "arm-arch=armv7" >> $GITHUB_OUTPUT
            echo "data-separator=:" >> $GITHUB_OUTPUT
            ;;
          linux-aarch64)
            echo "exe-extension=" >> $GITHUB_OUTPUT
            echo "is-windows=false" >> $GITHUB_OUTPUT
            echo "is-linux-arm=true" >> $GITHUB_OUTPUT
            echo "arm-arch=aarch64" >> $GITHUB_OUTPUT
            echo "data-separator=:" >> $GITHUB_OUTPUT
            ;;
        esac

    - name: Build for ARM architecture
      if: steps.setup-platform.outputs.is-linux-arm == 'true'
      uses: uraimo/run-on-arch-action@v2
      with:
        arch: ${{ steps.setup-platform.outputs.arm-arch }}
        distro: ubuntu22.04
        shell: /bin/bash
        githubToken: ${{ github.token }}
        setup: mkdir -p "${PWD}/${{ inputs.output-dir }}"
        dockerRunArgs: --volume "${PWD}/${{ inputs.output-dir }}:/${{ inputs.output-dir }}"
        install: |
          apt-get update -y
          apt-get install -y software-properties-common
          add-apt-repository -y ppa:deadsnakes/ppa
          apt-get update -y
          apt-get install --ignore-missing -y python${{ inputs.python-version }} python${{ inputs.python-version }}-dev python3-pip pkg-config gcc g++ patchelf binutils ${{ inputs.additional-arm-packages }}
          python${{ inputs.python-version }} -m pip install --upgrade pip setuptools wheel
        run: |
          python${{ inputs.python-version }} -m pip install --upgrade cffi  # TODO: this is esptool specific and might fail if there aren't all system packages installed
          adduser --disabled-password --gecos "" builder
          chmod -R a+rwx /home/runner/work
          su builder <<'EOF'
          export PATH=$PATH:/home/builder/.local/bin

          # Set pip extra index if provided
          if [ -n "${{ inputs.pip-extra-index-url }}" ]; then
            export PIP_EXTRA_INDEX_URL="${{ inputs.pip-extra-index-url }}"
          fi

          # Install PyInstaller
          if [ "${{ inputs.pyinstaller-version }}" = "latest" ]; then
            python${{ inputs.python-version }} -m pip install pyinstaller
          else
            python${{ inputs.python-version }} -m pip install pyinstaller==${{ inputs.pyinstaller-version }}
          fi

          # Install dependencies
          ${{ inputs.install-deps-command }}

          # Build each file
          for file in ${{ inputs.python-files }}; do
            echo "Building $file for ${{ inputs.target-platform }}..."

            cmd="python${{ inputs.python-version }} -m PyInstaller --onefile --distpath=${{ inputs.output-dir }}"

            # Add include-data-dirs using Python script
            echo "Processing include-data-dirs for $file..."
            include_flags=$(python${{ inputs.python-version }} $GITHUB_ACTION_PATH/process_include_dirs.py '${{ inputs.include-data-dirs }}' '${{ steps.setup-platform.outputs.data-separator }}' $file)
            echo "Include flags result: '$include_flags'"
            if [ -n "$include_flags" ]; then
              cmd="$cmd $include_flags"
              echo "Added include flags to command"
            else
              echo "No include flags generated"
            fi

            # Add additional arguments
            if [ -n "${{ inputs.additional-args }}" ]; then
              cmd="$cmd ${{ inputs.additional-args }}"
            fi

            cmd="$cmd $file"
            echo "Executing: $cmd"
            eval "$cmd"
          done

          # Test binaries
          for file in ${{ inputs.python-files }}; do
            base_name=$(basename "$file" .py)
            executable="${{ inputs.output-dir }}/${base_name}${{ steps.setup-platform.outputs.exe-extension }}"
            echo "Testing $executable..."
            if [ -f "$executable" ]; then
              echo "✓ $executable exists ($(du -h "$executable" | cut -f1))"
              "$executable" ${{ inputs.test-command-args }} || exit 1
            else
              echo "✗ $executable not found"
              exit 1
            fi
          done
          EOF

    - name: Install PyInstaller (non-ARM)
      if: steps.setup-platform.outputs.is-linux-arm != 'true'
      shell: bash
      run: |
        if [ -n "${{ inputs.pip-extra-index-url }}" ]; then
          echo "PIP_EXTRA_INDEX_URL=${{ inputs.pip-extra-index-url }}" >> $GITHUB_ENV
        fi

        if [ "${{ inputs.pyinstaller-version }}" = "latest" ]; then
          python -m pip install pyinstaller
        else
          python -m pip install pyinstaller==${{ inputs.pyinstaller-version }}
        fi

    - name: Install project dependencies (non-ARM)
      if: steps.setup-platform.outputs.is-linux-arm != 'true'
      shell: bash
      run: ${{ inputs.install-deps-command }}

    - name: Build with PyInstaller (non-ARM)
      if: steps.setup-platform.outputs.is-linux-arm != 'true'
      id: build
      shell: bash
      run: |
        # Build each Python file
        for file in ${{ inputs.python-files }}; do
          echo "Building $file for ${{ inputs.target-platform }}..."

          # Start building the command
          cmd="python -m PyInstaller --onefile --distpath=${{ inputs.output-dir }}"

          # Windows-specific options
          if [ "${{ steps.setup-platform.outputs.is-windows }}" = "true" ]; then
            if [ -n "${{ inputs.icon-file }}" ]; then
              cmd="$cmd --icon=${{ inputs.icon-file }}"
            fi
          fi

          # Add include-data-dirs using Python script
          echo "Processing include-data-dirs for $file..."
          include_flags=$(python $GITHUB_ACTION_PATH/process_include_dirs.py '${{ inputs.include-data-dirs }}' '${{ steps.setup-platform.outputs.data-separator }}' $file)
          echo "Include flags result: '$include_flags'"
          if [ -n "$include_flags" ]; then
            cmd="$cmd $include_flags"
            echo "Added include flags to command"
          else
            echo "No include flags generated"
          fi

          # Add additional arguments
          if [ -n "${{ inputs.additional-args }}" ]; then
            cmd="$cmd ${{ inputs.additional-args }}"
          fi

          # Add the file to build
          cmd="$cmd $file"

          echo "Executing: $cmd"
          eval "$cmd"
        done

        echo "success=true" >> $GITHUB_OUTPUT

    - name: Verify builds (non-ARM)
      if: steps.setup-platform.outputs.is-linux-arm != 'true'
      shell: bash
      run: |
        echo "Verifying built executables..."
        for file in ${{ inputs.python-files }}; do
          base_name=$(basename "$file" .py)
          executable="${{ inputs.output-dir }}/${base_name}${{ steps.setup-platform.outputs.exe-extension }}"

          if [ -f "$executable" ]; then
            echo "✓ $executable exists ($(du -h "$executable" | cut -f1))"
            # Test that it runs
            if "$executable" ${{ inputs.test-command-args }}; then
              echo "✓ $executable runs successfully"
            else
              echo "⚠ $executable may have issues"
              exit 1
            fi
          else
            echo "✗ $executable not found"
            exit 1
          fi
        done
