name: 'Nuitka Multi-Architecture Build'
description: 'Build Python applications into standalone executables using Nuitka for multiple architectures'
inputs:
  python-files:
    description: 'Space-separated list of Python files to build'
    required: true
  output-dir:
    description: 'Output directory for built executables'
    required: true
  include-data-dirs:
    description: 'JSON array of data directories to include (e.g. [{"src": "./data", "dest": "./data"}])'
    required: false
    default: '[]'
  icon-file:
    description: 'Path to icon file (Windows only)'
    required: false
    default: ''
  target-platform:
    description: 'Target platform: windows, linux-amd64, macos-amd64, macos-arm64, linux-armv7, linux-aarch64'
    required: true
  python-version:
    description: 'Python version to use'
    required: false
    default: '3.11'
  nuitka-version:
    description: 'Nuitka version to install'
    required: false
    default: 'latest'
  additional-args:
    description: 'Additional Nuitka arguments'
    required: false
    default: ''
  pip-extra-index-url:
    description: 'Extra pip index URL'
    required: false
    default: ''
  install-deps-command:
    description: 'Command to install project dependencies'
    required: false
    default: 'pip install --user --prefer-binary -e .'
  test-command-suffix:
    description: 'Command suffix to test binaries (e.g. "-h")'
    required: false
    default: '-h'
  additional-packages:
    description: 'Additional system packages to install (space-separated)'
    required: false
    default: ''
  enable-cache:
    description: 'Enable build caching'
    required: false
    default: 'true'
  cache-key-suffix:
    description: 'Additional cache key suffix for cache invalidation'
    required: false
    default: ''

outputs:
  executable-extension:
    description: 'File extension of built executables'
    value: ${{ steps.setup-platform.outputs.exe-extension }}
  build-success:
    description: 'Whether the build was successful'
    value: ${{ steps.build.outputs.success }}

runs:
  using: 'composite'
  steps:
    - name: Setup platform variables
      id: setup-platform
      shell: bash
      run: |
        case "${{ inputs.target-platform }}" in
          windows)
            echo "exe-extension=.exe" >> $GITHUB_OUTPUT
            echo "is-windows=true" >> $GITHUB_OUTPUT
            echo "is-arm=false" >> $GITHUB_OUTPUT
            echo "runner-arch=x64" >> $GITHUB_OUTPUT
            ;;
          linux-amd64)
            echo "exe-extension=.bin" >> $GITHUB_OUTPUT
            echo "is-windows=false" >> $GITHUB_OUTPUT
            echo "is-arm=false" >> $GITHUB_OUTPUT
            echo "runner-arch=x64" >> $GITHUB_OUTPUT
            ;;
          macos-amd64|macos-arm64)
            echo "exe-extension=.bin" >> $GITHUB_OUTPUT
            echo "is-windows=false" >> $GITHUB_OUTPUT
            echo "is-arm=false" >> $GITHUB_OUTPUT
            echo "runner-arch=x64" >> $GITHUB_OUTPUT
            ;;
          linux-armv7)
            echo "exe-extension=.bin" >> $GITHUB_OUTPUT
            echo "is-windows=false" >> $GITHUB_OUTPUT
            echo "is-arm=true" >> $GITHUB_OUTPUT
            echo "arm-arch=armv7" >> $GITHUB_OUTPUT
            ;;
          linux-aarch64)
            echo "exe-extension=.bin" >> $GITHUB_OUTPUT
            echo "is-windows=false" >> $GITHUB_OUTPUT
            echo "is-arm=true" >> $GITHUB_OUTPUT
            echo "arm-arch=aarch64" >> $GITHUB_OUTPUT
            ;;
        esac

    - name: Get cache key components
      id: cache-key
      shell: bash
      run: |
        # Create a hash of source files for cache invalidation
        if command -v sha256sum >/dev/null 2>&1; then
          SOURCE_HASH=$(find . -name "*.py" -type f -exec sha256sum {} \; | sha256sum | cut -d' ' -f1)
        elif command -v shasum >/dev/null 2>&1; then
          SOURCE_HASH=$(find . -name "*.py" -type f -exec shasum -a 256 {} \; | shasum -a 256 | cut -d' ' -f1)
        else
          SOURCE_HASH=$(date +%Y%m%d)  # Fallback to date
        fi
        echo "source-hash=$SOURCE_HASH" >> $GITHUB_OUTPUT
        echo "python-version=${{ inputs.python-version }}" >> $GITHUB_OUTPUT
        echo "nuitka-version=${{ inputs.nuitka-version }}" >> $GITHUB_OUTPUT

    - name: Setup cache paths
      id: cache-paths
      shell: bash
      run: |
        case "${{ inputs.target-platform }}" in
          windows)
            echo "nuitka-cache=C:\\Users\\runneradmin\\AppData\\Local\\Nuitka\\Nuitka" >> $GITHUB_OUTPUT
            echo "ccache-path=C:\\Users\\runneradmin\\AppData\\Local\\ccache" >> $GITHUB_OUTPUT
            echo "pip-cache=C:\\Users\\runneradmin\\AppData\\Local\\pip\\Cache" >> $GITHUB_OUTPUT
            ;;
          macos-*)
            echo "nuitka-cache=$HOME/Library/Caches/Nuitka" >> $GITHUB_OUTPUT
            echo "ccache-path=$HOME/Library/Caches/ccache" >> $GITHUB_OUTPUT
            echo "pip-cache=$HOME/Library/Caches/pip" >> $GITHUB_OUTPUT
            ;;
          *)
            echo "nuitka-cache=$HOME/.cache/nuitka" >> $GITHUB_OUTPUT
            echo "ccache-path=$HOME/.cache/ccache" >> $GITHUB_OUTPUT
            echo "pip-cache=$HOME/.cache/pip" >> $GITHUB_OUTPUT
            ;;
        esac

    - name: Cache build artifacts
      if: inputs.enable-cache == 'true'
      uses: actions/cache@v4
      with:
        path: |
          ${{ steps.cache-paths.outputs.nuitka-cache }}
          ${{ steps.cache-paths.outputs.ccache-path }}
          ${{ steps.cache-paths.outputs.pip-cache }}
        key: build-cache-${{ inputs.target-platform }}-${{ steps.cache-key.outputs.source-hash }}
        restore-keys: |
          build-cache-${{ inputs.target-platform }}-

    - name: Cache Nuitka dependencies
      if: inputs.enable-cache == 'true'
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/nuitka
          ~/.cache/pip
          ~/.cache/ccache
        key: nuitka-${{ inputs.target-platform }}-py${{ steps.cache-key.outputs.python-version }}-nuitka${{ steps.cache-key.outputs.nuitka-version }}-${{ steps.cache-key.outputs.source-hash }}-${{ inputs.cache-key-suffix }}
        restore-keys: |
          nuitka-${{ inputs.target-platform }}-py${{ steps.cache-key.outputs.python-version }}-nuitka${{ steps.cache-key.outputs.nuitka-version }}-
          nuitka-${{ inputs.target-platform }}-py${{ steps.cache-key.outputs.python-version }}-

    - name: Cache pip packages
      if: inputs.enable-cache == 'true'
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/pip
          ~/.local/lib/python*/site-packages
        key: pip-${{ inputs.target-platform }}-py${{ inputs.python-version }}-${{ hashFiles('**/requirements*.txt', '**/setup.py', '**/pyproject.toml') }}
        restore-keys: |
          pip-${{ inputs.target-platform }}-py${{ inputs.python-version }}-

    - name: Cache Nuitka installation
      if: inputs.enable-cache == 'true'
      uses: actions/cache@v4
      with:
        path: |
          ~/.local/lib/python*/site-packages/nuitka*
          ~/.local/bin/nuitka*
        key: nuitka-install-${{ inputs.target-platform }}-${{ inputs.nuitka-version }}-py${{ inputs.python-version }}

    - name: Check Nuitka installation
      id: nuitka-check
      shell: bash
      run: |
        if python -m nuitka --version >/dev/null 2>&1; then
          echo "installed=true" >> $GITHUB_OUTPUT
        else
          echo "installed=false" >> $GITHUB_OUTPUT
        fi

    - name: Build for ARM architecture
      if: steps.setup-platform.outputs.is-arm == 'true'
      uses: uraimo/run-on-arch-action@v2
      with:
        arch: ${{ steps.setup-platform.outputs.arm-arch }}
        distro: ubuntu22.04
        shell: /bin/bash
        githubToken: ${{ github.token }}
        setup: mkdir -p "${PWD}/${{ inputs.output-dir }}"
        dockerRunArgs: --volume "${PWD}/${{ inputs.output-dir }}:/${{ inputs.output-dir }}"
        install: |
          apt-get update -y
          apt-get install -y software-properties-common
          add-apt-repository -y ppa:deadsnakes/ppa
          apt-get update -y
          apt-get install --ignore-missing -y python${{ inputs.python-version }} python${{ inputs.python-version }}-dev python3-pip pkg-config openssl libffi-dev libffi7 libssl-dev cargo rustc gcc g++ patchelf ${{ inputs.additional-packages }}
          python${{ inputs.python-version }} -m pip install --upgrade pip setuptools wheel
          apt-get install -y ccache
          export CCACHE_DIR=/home/runner/.cache/ccache
          export CCACHE_MAXSIZE=4G
          export CCACHE_COMPRESS=1
          export CCACHE_COMPILERCHECK=mtime
          export CCACHE_SLOPPINESS=pch_defines,time_macros
          export NUITKA_CCACHE_BINARY=$(which ccache)
          mkdir -p $CCACHE_DIR
          chmod 777 $CCACHE_DIR
        run: |
          python${{ inputs.python-version }} -m pip install --upgrade cffi
          adduser --disabled-password --gecos "" builder
          chmod -R a+rwx /home/runner/work
          su builder <<'EOF'
          export PATH=$PATH:/home/builder/.local/bin

          # Set pip extra index if provided
          if [ -n "${{ inputs.pip-extra-index-url }}" ]; then
            export PIP_EXTRA_INDEX_URL="${{ inputs.pip-extra-index-url }}"
          fi

          # Install Nuitka
          if [ "${{ inputs.nuitka-version }}" = "latest" ]; then
            python${{ inputs.python-version }} -m pip install nuitka
          else
            python${{ inputs.python-version }} -m pip install nuitka==${{ inputs.nuitka-version }}
          fi

          # Install dependencies
          ${{ inputs.install-deps-command }}

          # Build each file
          for file in ${{ inputs.python-files }}; do
            echo "Building $file for ${{ inputs.target-platform }}..."

            cmd="python${{ inputs.python-version }} -m nuitka --onefile --follow-imports --output-dir=${{ inputs.output-dir }}"

            # Add memory optimization flags
            cmd="$cmd --jobs=$(nproc 2>/dev/null || echo 4)"

            # Add include-data-dirs using Python script
            include_flags=$(python${{ inputs.python-version }} $GITHUB_ACTION_PATH/process_include_dirs.py '${{ inputs.include-data-dirs }}')
            if [ -n "$include_flags" ]; then
              cmd="$cmd $include_flags"
            fi

            # Add additional arguments
            if [ -n "${{ inputs.additional-args }}" ]; then
              cmd="$cmd ${{ inputs.additional-args }}"
            fi

            # Add size optimization flags
            cmd="$cmd --enable-plugin=anti-bloat"
            cmd="$cmd --noinclude-pytest-mode=nofollow"
            cmd="$cmd --noinclude-setuptools-mode=nofollow"
            cmd="$cmd --noinclude-unittest-mode=nofollow"

            # Use --nofollow-import-to for packages without dedicated modes
            cmd="$cmd --nofollow-import-to=distutils,pip,wheel,pkg_resources"
            cmd="$cmd --nofollow-import-to=test,tests,testing,doctest"
            cmd="$cmd --nofollow-import-to=IPython,jupyter,notebook"
            cmd="$cmd --nofollow-import-to=scipy,matplotlib,pandas"
            cmd="$cmd --nofollow-import-to=dask,numba"
            cmd="$cmd --nofollow-import-to=turtle,pdb,pydoc"
            cmd="$cmd --nofollow-import-to=xml.etree.cElementTree"
            cmd="$cmd --nofollow-import-to=asyncio.windows_events,asyncio.windows_utils"

            # Special handling for bitstring library (fixes BitStream compilation issues)
            cmd="$cmd --follow-import-to=bitstring"
            cmd="$cmd --include-module=bitstring"
            cmd="$cmd --include-package=bitstring"
            cmd="$cmd --include-package-data=bitstring"

            # Add this flag:
            cmd="$cmd --lto=no"  # Significantly faster compilation

            cmd="$cmd $file"
            echo "Executing: $cmd"
            eval "$cmd"
          done

          # Test binaries
          for file in ${{ inputs.python-files }}; do
            base_name=$(basename "$file" .py)
            executable="${{ inputs.output-dir }}/${base_name}${{ steps.setup-platform.outputs.exe-extension }}"
            echo "Testing $executable..."
            if [ -f "$executable" ]; then
              echo "✓ $executable exists ($(du -h "$executable" | cut -f1))"
              "$executable" ${{ inputs.test-command-suffix }} || exit 1
            else
              echo "✗ $executable not found"
              exit 1
            fi
          done
          EOF

    - name: Install Nuitka (non-ARM)
      if: steps.setup-platform.outputs.is-arm != 'true' && steps.nuitka-check.outputs.installed != 'true'
      shell: bash
      run: |
        if [ -n "${{ inputs.pip-extra-index-url }}" ]; then
          export PIP_EXTRA_INDEX_URL="${{ inputs.pip-extra-index-url }}"
        fi

        if [ "${{ inputs.nuitka-version }}" = "latest" ]; then
          python -m pip install nuitka
        else
          python -m pip install nuitka==${{ inputs.nuitka-version }}
        fi

    - name: Install project dependencies (non-ARM)
      if: steps.setup-platform.outputs.is-arm != 'true'
      shell: bash
      run: |
        if [ -n "${{ inputs.pip-extra-index-url }}" ]; then
          export PIP_EXTRA_INDEX_URL="${{ inputs.pip-extra-index-url }}"
        fi

        ${{ inputs.install-deps-command }}

    - name: Setup ccache (non-ARM)
      if: steps.setup-platform.outputs.is-arm != 'true' && inputs.enable-cache == 'true'
      shell: bash
      run: |
        case "${{ inputs.target-platform }}" in
          windows)
            # Nuitka will auto-download ccache on Windows
            echo "NUITKA_CCACHE_BINARY=auto" >> $GITHUB_ENV
            ;;
          macos-*)
            # Install ccache on macOS
            if command -v brew >/dev/null 2>&1; then
              brew install ccache
            fi
            echo "NUITKA_CCACHE_BINARY=$(which ccache || echo auto)" >> $GITHUB_ENV
            ;;
          *)
            # Install ccache on Linux
            sudo apt-get update && sudo apt-get install -y ccache
            echo "NUITKA_CCACHE_BINARY=$(which ccache)" >> $GITHUB_ENV
            ;;
        esac

        # Set ccache options
        echo "CCACHE_DIR=${{ steps.cache-paths.outputs.ccache-path }}" >> $GITHUB_ENV
        echo "CCACHE_MAXSIZE=4G" >> $GITHUB_ENV
        echo "CCACHE_COMPRESS=1" >> $GITHUB_ENV
        echo "CCACHE_COMPILERCHECK=mtime" >> $GITHUB_ENV
        echo "CCACHE_SLOPPINESS=pch_defines,time_macros" >> $GITHUB_ENV

    - name: Build with Nuitka (non-ARM)
      if: steps.setup-platform.outputs.is-arm != 'true'
      id: build
      shell: bash
      run: |
        if [ -n "${{ inputs.pip-extra-index-url }}" ]; then
          export PIP_EXTRA_INDEX_URL="${{ inputs.pip-extra-index-url }}"
        fi

        # Build each Python file
        for file in ${{ inputs.python-files }}; do
          echo "Building $file for ${{ inputs.target-platform }}..."

          # Start building the command
          cmd="python -m nuitka --onefile --follow-imports --output-dir=${{ inputs.output-dir }}"

          # Windows-specific optimizations
          if [ "${{ steps.setup-platform.outputs.is-windows }}" = "true" ]; then
            cmd="$cmd --mingw64"
            if [ -n "${{ inputs.icon-file }}" ]; then
              cmd="$cmd --assume-yes-for-downloads"
              cmd="$cmd --windows-icon-from-ico=${{ inputs.icon-file }}"
            fi
          fi

          cmd="$cmd --jobs=$(nproc 2>/dev/null || echo 4)"

          # Aggressive size optimizations
          cmd="$cmd --enable-plugin=anti-bloat"
          cmd="$cmd --noinclude-pytest-mode=nofollow"
          cmd="$cmd --noinclude-setuptools-mode=nofollow"
          cmd="$cmd --noinclude-unittest-mode=nofollow"

          # Use --nofollow-import-to for other packages
          cmd="$cmd --nofollow-import-to=distutils,pip,wheel,pkg_resources"
          cmd="$cmd --nofollow-import-to=test,tests,testing,doctest"
          cmd="$cmd --nofollow-import-to=IPython,jupyter,notebook"
          cmd="$cmd --nofollow-import-to=scipy,matplotlib,pandas"
          cmd="$cmd --nofollow-import-to=dask,numba"
          cmd="$cmd --nofollow-import-to=turtle,pdb,pydoc"
          cmd="$cmd --nofollow-import-to=xml.etree.cElementTree"
          cmd="$cmd --nofollow-import-to=asyncio.windows_events,asyncio.windows_utils"

          # Special handling for bitstring library (fixes BitStream compilation issues)
          cmd="$cmd --follow-import-to=bitstring"
          cmd="$cmd --include-module=bitstring"
          cmd="$cmd --include-package=bitstring"
          cmd="$cmd --include-package-data=bitstring"

          # Add include-data-dirs using Python script
          include_flags=$(python $GITHUB_ACTION_PATH/process_include_dirs.py '${{ inputs.include-data-dirs }}')
          if [ -n "$include_flags" ]; then
            cmd="$cmd $include_flags"
          fi

          # Add additional arguments
          if [ -n "${{ inputs.additional-args }}" ]; then
            cmd="$cmd ${{ inputs.additional-args }}"
          fi

          # Add this flag:
          cmd="$cmd --lto=no"  # Significantly faster compilation

          # Add the file to build
          cmd="$cmd $file"

          echo "Executing: $cmd"
          eval "$cmd"
        done

        echo "success=true" >> $GITHUB_OUTPUT

    - name: Verify builds (non-ARM)
      if: steps.setup-platform.outputs.is-arm != 'true'
      shell: bash
      run: |
        echo "Verifying built executables..."
        for file in ${{ inputs.python-files }}; do
          base_name=$(basename "$file" .py)
          executable="${{ inputs.output-dir }}/${base_name}${{ steps.setup-platform.outputs.exe-extension }}"

          if [ -f "$executable" ]; then
            echo "✓ $executable exists ($(du -h "$executable" | cut -f1))"
            # Test that it runs
            if "$executable" ${{ inputs.test-command-suffix }} > /dev/null 2>&1; then
              echo "✓ $executable runs successfully"
            else
              echo "⚠ $executable may have issues"
            fi
          else
            echo "✗ $executable not found"
            exit 1
          fi
        done

    - name: Show cache statistics
      if: inputs.enable-cache == 'true'
      shell: bash
      run: |
        echo "=== Cache Statistics ==="
        if command -v ccache >/dev/null 2>&1; then
          echo "ccache stats:"
          ccache -s || echo "ccache not available"
        fi

        echo "Cache directories:"
        du -sh ${{ steps.cache-paths.outputs.nuitka-cache }} 2>/dev/null || echo "Nuitka cache not found"
        du -sh ${{ steps.cache-paths.outputs.ccache-path }} 2>/dev/null || echo "ccache not found"
        du -sh ${{ steps.cache-paths.outputs.pip-cache }} 2>/dev/null || echo "pip cache not found"
